var R=Object.defineProperty,w=Object.defineProperties;var j=Object.getOwnPropertyDescriptors;var h=Object.getOwnPropertySymbols;var k=Object.prototype.hasOwnProperty,S=Object.prototype.propertyIsEnumerable;var P=(r,e,t)=>e in r?R(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,p=(r,e)=>{for(var t in e||(e={}))k.call(e,t)&&P(r,t,e[t]);if(h)for(var t of h(e))S.call(e,t)&&P(r,t,e[t]);return r},b=(r,e)=>w(r,j(e));var C=(r,e)=>{var t={};for(var n in r)k.call(r,n)&&e.indexOf(n)<0&&(t[n]=r[n]);if(r!=null&&h)for(var n of h(r))e.indexOf(n)<0&&S.call(r,n)&&(t[n]=r[n]);return t};var y=(r,e,t)=>new Promise((n,i)=>{var o=s=>{try{f(t.next(s))}catch(d){i(d)}},a=s=>{try{f(t.throw(s))}catch(d){i(d)}},f=s=>s.done?n(s.value):Promise.resolve(s.value).then(o,a);f((t=t.apply(r,e)).next())});import*as u from"react";import{useContext as A,useEffect as B}from"react";import{useObserver as H}from"react-ob";import{createContext as V}from"react";var m=V(void 0);var E={abortEarly:!1};function O(r){return!!r._blacklist}function L(r,e,t){return y(this,null,function*(){let n={};if(t)try{yield r.validateAt(t,e,E)}catch(i){i&&i.errors&&i.errors[0]&&(n[t]=i.errors[0])}else{let i=Object.keys(e);for(let o of i)try{yield r.validateAt(o,e,E)}catch(a){a&&a.errors&&a.errors[0]&&(n[o]=a.errors[0])}}return n})}function F(r,e){let t={};return Object.keys(r.touched).forEach(n=>{if(r.touched[n]){let i=e[n];i!==void 0&&(t[n]=i)}}),t}function T(r,e){return y(this,null,function*(){if(r.validate){let t=yield Promise.resolve(r.validate(r.val,e));Object.assign(r.errors,F(r,t))}else if(r.validateSchema){if(O(r.validateSchema)){let t=yield L(r.validateSchema,r.val,e);Object.assign(r.errors,F(r,t))}else if(r.validateSchema.isSoke){let t=r.validateSchema.validate(r.val,e);Object.assign(r.errors,F(r,t))}}r.next()})}var K={name:"",value:"",error:"",onChange:r=>{},onBlur:r=>{}};function Y(r,e,t){if(!r)return K;let n=H(r,o=>t?t=="error"?[r.errors[e]]:[o[e]]:[o[e],r.errors[e]]);B(()=>{r.val[e]&&i.onChange(r.val[e])},[]);let i={name:e,value:n[e]==null?"":n[e],error:typeof r.errors[e]=="undefined"?"":r.errors[e],onBlur:o=>{o.persist&&o.persist(),r.touched[e]||(r.touched[e]=!0,i.onChange(n[e]))},onChange:o=>{r.touched[e]||(r.touched[e]=!0);let a=typeof o,f;if(a==="undefined")f="";else if(a==="object"&&(o.currentTarget||o.target)){let l=o.currentTarget||o.target,c=l.type;if(c==="checkbox"||c==="radio")f=!!l.checked;else if(l.multiple){let v=l.options,x=[];for(var s=0,d=v.length;s<d;s++)v[s].selected&&x.push(v[s].value);f=x}else f=l.value}else f=o;r.val[e]=f,r.handleChange&&(r.val=r.handleChange(r.val,e)),T(r,e)}};return i}function g(r,e){let t=A(m);return Y(t,r,e)}function ar({name:r}){let e=g(r,"error");return u.createElement(u.Fragment,null,e.error)}function dr({name:r,children:e,loadType:t}){let n=g(r,t);return e(n)}function mr(r){return function(a){var f=a,{name:t,loadType:n,onChange:i}=f,o=C(f,["name","loadType","onChange"]);if(t){let s=g(t,n);return i&&i(s.value),u.createElement(r,p(p({},s),o))}return u.createElement(r,p({},o))}}var M=m.Provider;function hr(i){var o=i,{children:r,onSubmit:e,value:t}=o,n=C(o,["children","onSubmit","value"]);return u.createElement(M,{value:t},u.createElement("form",p({onSubmit:a=>{a.preventDefault(),e&&e(a)}},n),r))}import{useContext as D}from"react";import{useObserver as N}from"react-ob";var _={names:[],values:{},errors:{},onChange:(r,e)=>{},keepValues:r=>{}};function q(r,e,t){if(!r)return _;N(r,o=>{let a=[];return t?t=="error"?(e.forEach(f=>{a.push(r.errors[f])}),a):(e.forEach(f=>{a.push(o[f])}),a):(e.forEach(f=>{a.push(o[f]),a.push(r.errors[f])}),a)});let n={},i={};return e.forEach(o=>{n[o]=r.val[o],i[o]=r.errors[o]||""}),{names:e,values:n,errors:i,onChange:(o,a)=>{r.val[o]=a,r.next()},keepValues:r.keepValues}}function kr(r,e){let t=D(m);return q(t,r,e)}import{useMemo as z,useRef as G}from"react";import{CreateObserver as I}from"react-ob";function Lr({initialValues:r,initErrors:e,validate:t,validateSchema:n,handleChange:i}){let o=G(I(r));return z(()=>{let a=Object.keys(r),f={};return a.forEach(s=>{f[s]=!1}),o.current=b(p({},o.current),{validate:t,errors:e||{},fields:a,touched:f,validateSchema:n,findFirstError:()=>{let s=o.current.validateSchema;if(s.isSoke)return s.firstError(o.current.errors);let d=o.current.fields,l="";return d.forEach(c=>{!l&&o.current.errors[c]&&(l=o.current.errors[c])}),l},validateAll:()=>y(this,null,function*(){let s=o.current.validateSchema;return s.isSoke?s.schemaKeys.forEach(d=>{o.current.touched[d]=!0}):o.current.fields.forEach(l=>{o.current.touched[l]=!0}),yield T(o.current),o.current.findFirstError()}),validateKey:s=>y(this,null,function*(){return o.current.touched[s]=!0,yield T(o.current,s),o.current.errors[s]}),keepValues:s=>{let d=s||o.current.fields,l={};return d.forEach(c=>{l[c]=o.current.val[c]}),l},handleChange:i}),o.current},[])}export{ar as ErrorMessage,dr as Field,mr as FieldHOC,hr as LessForm,g as useField,Y as useFieldByContext,kr as useFields,q as useFieldsByContext,Lr as useForm};
