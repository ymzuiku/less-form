var M=Object.defineProperty,V=Object.defineProperties;var H=Object.getOwnPropertyDescriptors;var T=Object.getOwnPropertySymbols;var E=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable;var P=(r,e,t)=>e in r?M(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,p=(r,e)=>{for(var t in e||(e={}))E.call(e,t)&&P(r,t,e[t]);if(T)for(var t of T(e))k.call(e,t)&&P(r,t,e[t]);return r},j=(r,e)=>V(r,H(e));var b=(r,e)=>{var t={};for(var o in r)E.call(r,o)&&e.indexOf(o)<0&&(t[o]=r[o]);if(r!=null&&T)for(var o of T(r))e.indexOf(o)<0&&k.call(r,o)&&(t[o]=r[o]);return t};var y=(r,e,t)=>new Promise((o,a)=>{var s=l=>{try{i(t.next(l))}catch(f){a(f)}},n=l=>{try{i(t.throw(l))}catch(f){a(f)}},i=l=>l.done?o(l.value):Promise.resolve(l.value).then(s,n);i((t=t.apply(r,e)).next())});import*as u from"react";export*from"soke";import{useContext as X,useEffect as Z}from"react";import"react";import{useEffect as I,useMemo as yr,useRef as N,useState as $}from"react";var _=Object.defineProperty,w=Object.getOwnPropertySymbols,z=Object.prototype.hasOwnProperty,K=Object.prototype.propertyIsEnumerable,A=(r,e,t)=>e in r?_(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Y=(r,e)=>{for(var t in e||(e={}))z.call(e,t)&&A(r,t,e[t]);if(w)for(var t of w(e))K.call(e,t)&&A(r,t,e[t]);return r},q=typeof Element!="undefined",D=typeof Map=="function",G=typeof Set=="function",J=typeof ArrayBuffer=="function"&&!!ArrayBuffer.isView;function x(r,e){if(r===e)return!0;if(r&&e&&typeof r=="object"&&typeof e=="object"){if(r.constructor!==e.constructor)return!1;let t,o,a;if(Array.isArray(r)){if(t=r.length,t!=e.length)return!1;for(o=t;o--!==0;)if(!x(r[o],e[o]))return!1;return!0}let s;if(D&&r instanceof Map&&e instanceof Map){if(r.size!==e.size)return!1;for(s=r.entries();!(o=s.next()).done;)if(!e.has(o.value[0]))return!1;for(s=r.entries();!(o=s.next()).done;)if(!x(o.value[1],e.get(o.value[0])))return!1;return!0}if(G&&r instanceof Set&&e instanceof Set){if(r.size!==e.size)return!1;for(s=r.entries();!(o=s.next()).done;)if(!e.has(o.value[0]))return!1;return!0}if(J&&ArrayBuffer.isView(r)&&ArrayBuffer.isView(e)){if(t=r.length,t!=e.length)return!1;for(o=t;o--!==0;)if(r[o]!==e[o])return!1;return!0}if(r.constructor===RegExp)return r.source===e.source&&r.flags===e.flags;if(r.valueOf!==Object.prototype.valueOf)return r.valueOf()===e.valueOf();if(r.toString!==Object.prototype.toString)return r.toString()===e.toString();if(a=Object.keys(r),t=a.length,t!==Object.keys(e).length)return!1;for(o=t;o--!==0;)if(!Object.prototype.hasOwnProperty.call(e,a[o]))return!1;if(q&&r instanceof Element)return!1;for(o=t;o--!==0;)if(!((a[o]==="_owner"||a[o]==="__v"||a[o]==="__o")&&r.$$typeof)&&!x(r[a[o]],e[a[o]]))return!1;return!0}return r!==r&&e!==e}function Q(r,e){try{return x(r,e)}catch(t){if((t.message||"").match(/stack|recursion/i))return console.warn("react-fast-compare cannot handle circular refs"),!1;throw t}}function F(r,e){let[t,o]=$(r.val),a=N(e(r.val));return I(()=>{let s=()=>{let n=e(r.val),i=!Q(n,a.current);a.current=n,i&&o(Y({},r.val))};return r.subscribs.add(s),()=>{r.subscribs.delete(s)}},[]),t}function L(r){let e=new Set,t={subscribs:e,next:o=>{o?Promise.resolve(o(t.val)).then(()=>{e.forEach(a=>a())}):e.forEach(a=>a())},val:r};return t}import{createContext as U}from"react";var g=U(void 0);import{validateSoke as W}from"soke";var R={abortEarly:!1};function v(r){return!!r._blacklist}function B(r,e,t){return y(this,null,function*(){let o={};if(t)try{yield r.validateAt(t,e,R)}catch(a){a&&a.errors&&a.errors[0]&&(o[t]=a.errors[0])}else{let a=Object.keys(e);for(let s of a)try{yield r.validateAt(s,e,R)}catch(n){n&&n.errors&&n.errors[0]&&(o[s]=n.errors[0])}}return o})}function S(r,e){if(r.entryValidateAll)return e;let t={};return Object.keys(r.touched).forEach(o=>{if(r.touched[o]){let a=e[o];a!==void 0&&(t[o]=a)}}),t}function C(r,e){return y(this,null,function*(){if(r.validate){let t=yield Promise.resolve(r.validate(r.val,e));Object.assign(r.errors,S(r,t))}else if(r.validateSchema)if(v(r.validateSchema)){let t=yield B(r.validateSchema,r.val,e);Object.assign(r.errors,S(r,t))}else{let t=W(r.validateSchema,r.val,e);Object.assign(r.errors,S(r,t))}r.next()})}var rr={name:"",value:"",error:"",onChange:r=>{},onBlur:r=>{}};function er(r,e,t){if(!r)return rr;let o=F(r,s=>t?t=="error"?[r.errors[e]]:[s[e]]:[s[e],r.errors[e]]);Z(()=>{r.val[e]&&a.onChange(r.val[e])},[]);let a={name:e,value:o[e]==null?"":o[e],error:typeof r.errors[e]=="undefined"?"":r.errors[e],onBlur:s=>{s.persist&&s.persist(),r.touched[e]||(r.touched[e]=!0,a.onChange(o[e]))},onChange:s=>{r.touched[e]||(r.touched[e]=!0);let n=typeof s,i;if(n==="undefined")i="";else if(n==="object"&&(s.currentTarget||s.target)){let c=s.currentTarget||s.target,d=c.type;if(d==="checkbox"||d==="radio")i=!!c.checked;else if(c.multiple){let m=c.options,O=[];for(var l=0,f=m.length;l<f;l++)m[l].selected&&O.push(m[l].value);i=O}else i=c.value}else i=s;r.val[e]=i,r.handleChange&&(r.val=r.handleChange(r.val,e)),C(r,e)}};return a}function h(r,e){let t=X(g);return er(t,r,e)}function Pr({name:r}){let e=h(r,"error");return u.createElement(u.Fragment,null,e.error)}function Ar(o){var a=o,{name:r,children:e}=a,t=b(a,["name","children"]);let s=h(r);return u.createElement("input",p({name:r,value:s.value,onChange:s.onChange,onBlur:s.onBlur},t))}function Mr(r,e){return function(s){var n=s,{name:o}=n,a=b(n,["name"]);if(o){let i=h(o,e);return u.createElement(r,p(p({},i),a))}return u.createElement(r,p({},a))}}var tr=g.Provider;function _r(r){return u.createElement(tr,p({},r))}import{useContext as or}from"react";var nr={names:[],values:{},errors:{},onChange:(r,e)=>{},keepValues:r=>{}};function sr(r,e,t){if(!r)return nr;F(r,s=>{let n=[];return t?t=="error"?(e.forEach(i=>{n.push(r.errors[i])}),n):(e.forEach(i=>{n.push(s[i])}),n):(e.forEach(i=>{n.push(s[i]),n.push(r.errors[i])}),n)});let o={},a={};return e.forEach(s=>{o[s]=r.val[s],a[s]=r.errors[s]||""}),{names:e,values:o,errors:a,onChange:(s,n)=>{r.val[s]=n,r.next()},keepValues:r.keepValues}}function Nr(r,e){let t=or(g);return sr(t,r,e)}import{useEffect as ar,useMemo as ir,useRef as ur}from"react";import{firstError as fr}from"soke";function Wr({initialValues:r,initErrors:e,validate:t,entryValidateAll:o,validateSchema:a,handleChange:s}){let n=ur(L(r));return ar(()=>{o&&n.current.validateAll&&n.current.validateAll()},[]),ir(()=>{let i=Object.keys(r),l={};return i.forEach(f=>{l[f]=!1}),n.current=j(p({},n.current),{validate:t,errors:e||{},fields:i,touched:l,entryCheckAll:!!o,validateSchema:a,findFirstError:()=>{if(!v(n.current.validateSchema))return fr(n.current.validateSchema,n.current.errors);let f=n.current.fields,c="";return f.forEach(d=>{!c&&n.current.errors[d]&&(c=n.current.errors[d])}),c},validateAll:()=>y(this,null,function*(){return v(n.current.validateSchema)?n.current.fields.forEach(c=>{n.current.touched[c]=!0}):Object.keys(n.current.validateSchema).forEach(c=>{n.current.touched[c]=!0}),yield C(n.current),n.current.findFirstError()}),validateKey:f=>y(this,null,function*(){return n.current.touched[f]=!0,yield C(n.current,f),n.current.findFirstError()}),keepValues:f=>{let c=f||n.current.fields,d={};return c.forEach(m=>{d[m]=n.current.val[m]}),d},handleChange:s}),n.current},[])}export{Pr as ErrorMessage,Ar as Field,Mr as FieldHOC,_r as LessForm,h as useField,er as useFieldByContext,Nr as useFields,sr as useFieldsByContext,Wr as useForm};
