var R=Object.defineProperty,j=Object.defineProperties;var w=Object.getOwnPropertyDescriptors;var C=Object.getOwnPropertySymbols;var S=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable;var E=(e,r,t)=>r in e?R(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,d=(e,r)=>{for(var t in r||(r={}))S.call(r,t)&&E(e,t,r[t]);if(C)for(var t of C(r))k.call(r,t)&&E(e,t,r[t]);return e},b=(e,r)=>j(e,w(r));var T=(e,r)=>{var t={};for(var n in e)S.call(e,n)&&r.indexOf(n)<0&&(t[n]=e[n]);if(e!=null&&C)for(var n of C(e))r.indexOf(n)<0&&k.call(e,n)&&(t[n]=e[n]);return t};var y=(e,r,t)=>new Promise((n,s)=>{var o=a=>{try{u(t.next(a))}catch(c){s(c)}},i=a=>{try{u(t.throw(a))}catch(c){s(c)}},u=a=>a.done?n(a.value):Promise.resolve(a.value).then(o,i);u((t=t.apply(e,r)).next())});import*as l from"react";import{useContext as M,useEffect as A}from"react";import{useObserver as H}from"react-ob";import{createContext as B}from"react";var m=B(void 0);var P={abortEarly:!1};function O(e){return!!e._blacklist}function L(e,r,t){return y(this,null,function*(){let n={};if(t)try{yield e.validateAt(t,r,P)}catch(s){s&&s.errors&&s.errors[0]&&(n[t]=s.errors[0])}else{let s=Object.keys(r);for(let o of s)try{yield e.validateAt(o,r,P)}catch(i){i&&i.errors&&i.errors[0]&&(n[o]=i.errors[0])}}return n})}function F(e,r){let t={};return Object.keys(e.touched).forEach(n=>{if(e.touched[n]){let s=r[n];s!==void 0&&(t[n]=s)}}),t}function h(e,r){return y(this,null,function*(){if(e.validate){let t=yield Promise.resolve(e.validate(e.val,r));Object.assign(e.errors,F(e,t))}else if(e.validateSchema){if(O(e.validateSchema)){let t=yield L(e.validateSchema,e.val,r);Object.assign(e.errors,F(e,t))}else if(e.validateSchema.isSoke){let t=e.validateSchema.validate(e.val,r);Object.assign(e.errors,F(e,t))}}e.next()})}var V={name:"",value:"",error:"",onChange:e=>{},onBlur:e=>{}};function K(e,r,t){if(!e)return V;let n=H(e,o=>t?t=="error"?[e.errors[r]]:[o[r]]:[o[r],e.errors[r]]);A(()=>{e.val[r]&&s.onChange(e.val[r])},[]);let s={name:r,value:n[r]==null?"":n[r],error:typeof e.errors[r]=="undefined"?"":e.errors[r],onBlur:o=>{o.persist&&o.persist(),e.touched[r]||(e.touched[r]=!0,s.onChange(n[r]))},onChange:o=>{e.touched[r]||(e.touched[r]=!0);let i=typeof o,u;if(i==="undefined")u="";else if(i==="object"&&(o.currentTarget||o.target)){let f=o.currentTarget||o.target,p=f.type;if(p==="checkbox"||p==="radio")u=!!f.checked;else if(f.multiple){let v=f.options,x=[];for(var a=0,c=v.length;a<c;a++)v[a].selected&&x.push(v[a].value);u=x}else u=f.value}else u=o;e.val[r]=u,e.handleChange&&(e.val=e.handleChange(e.val,r)),h(e,r)}};return s}function g(e,r){let t=M(m);return K(t,e,r)}function ae({name:e}){let r=g(e,"error");return l.createElement(l.Fragment,null,r.error)}function le(n){var s=n,{name:e,children:r}=s,t=T(s,["name","children"]);let o=g(e);return l.createElement("input",d({name:e,value:o.value,onChange:o.onChange,onBlur:o.onBlur},t))}function pe(e,r){return function(o){var i=o,{name:n}=i,s=T(i,["name"]);if(n){let u=g(n,r);return l.createElement(e,d(d({},u),s))}return l.createElement(e,d({},s))}}var Y=m.Provider;function ge(e){return l.createElement(Y,d({},e))}import{useContext as I}from"react";import{useObserver as N}from"react-ob";var D={names:[],values:{},errors:{},onChange:(e,r)=>{},keepValues:e=>{}};function _(e,r,t){if(!e)return D;N(e,o=>{let i=[];return t?t=="error"?(r.forEach(u=>{i.push(e.errors[u])}),i):(r.forEach(u=>{i.push(o[u])}),i):(r.forEach(u=>{i.push(o[u]),i.push(e.errors[u])}),i)});let n={},s={};return r.forEach(o=>{n[o]=e.val[o],s[o]=e.errors[o]||""}),{names:r,values:n,errors:s,onChange:(o,i)=>{e.val[o]=i,e.next()},keepValues:e.keepValues}}function Fe(e,r){let t=I(m);return _(t,e,r)}import{useMemo as q,useRef as z}from"react";import{CreateObserver as G}from"react-ob";function Pe({initialValues:e,initErrors:r,validate:t,validateSchema:n,handleChange:s}){let o=z(G(e));return q(()=>{let i=Object.keys(e),u={};return i.forEach(a=>{u[a]=!1}),o.current=b(d({},o.current),{validate:t,errors:r||{},fields:i,touched:u,validateSchema:n,findFirstError:()=>{let a=o.current.validateSchema;if(a.isSoke)return a.firstError(o.current.errors);let c=o.current.fields,f="";return c.forEach(p=>{!f&&o.current.errors[p]&&(f=o.current.errors[p])}),f},validateAll:()=>y(this,null,function*(){let a=o.current.validateSchema;return a.isSoke?a.schemaKeys.forEach(c=>{o.current.touched[c]=!0}):o.current.fields.forEach(f=>{o.current.touched[f]=!0}),yield h(o.current),o.current.findFirstError()}),validateKey:a=>y(this,null,function*(){return o.current.touched[a]=!0,yield h(o.current,a),o.current.errors[a]}),keepValues:a=>{let c=a||o.current.fields,f={};return c.forEach(p=>{f[p]=o.current.val[p]}),f},handleChange:s}),o.current},[])}export{ae as ErrorMessage,le as Field,pe as FieldHOC,ge as LessForm,g as useField,K as useFieldByContext,Fe as useFields,_ as useFieldsByContext,Pe as useForm};
