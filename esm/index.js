var R=Object.defineProperty,w=Object.defineProperties;var j=Object.getOwnPropertyDescriptors;var h=Object.getOwnPropertySymbols;var k=Object.prototype.hasOwnProperty,S=Object.prototype.propertyIsEnumerable;var P=(r,e,o)=>e in r?R(r,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):r[e]=o,p=(r,e)=>{for(var o in e||(e={}))k.call(e,o)&&P(r,o,e[o]);if(h)for(var o of h(e))S.call(e,o)&&P(r,o,e[o]);return r},b=(r,e)=>w(r,j(e));var C=(r,e)=>{var o={};for(var n in r)k.call(r,n)&&e.indexOf(n)<0&&(o[n]=r[n]);if(r!=null&&h)for(var n of h(r))e.indexOf(n)<0&&S.call(r,n)&&(o[n]=r[n]);return o};var y=(r,e,o)=>new Promise((n,i)=>{var t=a=>{try{f(o.next(a))}catch(d){i(d)}},s=a=>{try{f(o.throw(a))}catch(d){i(d)}},f=a=>a.done?n(a.value):Promise.resolve(a.value).then(t,s);f((o=o.apply(r,e)).next())});import*as u from"react";import{useContext as A,useEffect as B}from"react";import{useObserver as K}from"react-ob";import{createContext as V}from"react";var m=V(void 0);var E={abortEarly:!1};function O(r){return!!r._blacklist}function L(r,e,o){return y(this,null,function*(){let n={};if(o)try{yield r.validateAt(o,e,E)}catch(i){i&&i.errors&&i.errors[0]&&(n[o]=i.errors[0])}else{let i=Object.keys(e);for(let t of i)try{yield r.validateAt(t,e,E)}catch(s){s&&s.errors&&s.errors[0]&&(n[t]=s.errors[0])}}return n})}function F(r,e){let o={};return Object.keys(r.touched).forEach(n=>{if(r.touched[n]){let i=e[n];i!==void 0&&(o[n]=i)}}),o}function T(r,e){return y(this,null,function*(){if(r.validate){let o=yield Promise.resolve(r.validate(r.val,e));Object.assign(r.errors,F(r,o))}else if(r.validateSchema){if(O(r.validateSchema)){let o=yield L(r.validateSchema,r.val,e);Object.assign(r.errors,F(r,o))}else if(r.validateSchema.isSoke){let o=r.validateSchema.validate(r.val,e);Object.assign(r.errors,F(r,o))}}r.next()})}var Y={name:"",value:"",error:"",onChange:r=>{},onBlur:r=>{}};function M(r,e,o){if(!r)return Y;let n=K(r,t=>o?o=="error"?[r.errors[e]]:[t[e]]:[t[e],r.errors[e]]);B(()=>{r.val[e]&&i.onChange(r.val[e])},[]);let i={name:e,value:n[e]==null?"":n[e],error:typeof r.errors[e]=="undefined"?"":r.errors[e],onBlur:t=>{t.persist&&t.persist(),r.touched[e]||(r.touched[e]=!0,i.onChange(n[e]))},onChange:t=>{r.touched[e]||(r.touched[e]=!0);let s=typeof t,f;if(s==="undefined")f="";else if(s==="object"&&(t.currentTarget||t.target)){let l=t.currentTarget||t.target,c=l.type;if(c==="checkbox"||c==="radio")f=!!l.checked;else if(l.multiple){let v=l.options,x=[];for(var a=0,d=v.length;a<d;a++)v[a].selected&&x.push(v[a].value);f=x}else f=l.value}else f=t;r.val[e]=f,r.handleChange&&(r.val=r.handleChange(r.val,e)),T(r,e)}};return i}function g(r,e){let o=A(m);return M(o,r,e)}function ar({name:r}){let e=g(r,"error");return u.createElement(u.Fragment,null,e.error)}function dr({name:r,children:e,loadType:o}){let n=g(r,o);return e(n)}function mr(r){return function(t){var s=t,{name:o,loadType:n}=s,i=C(s,["name","loadType"]);if(o){let f=g(o,n);return u.createElement(r,p(p({},f),i))}return u.createElement(r,p({},i))}}var H=m.Provider;function hr(i){var t=i,{children:r,onSubmit:e,value:o}=t,n=C(t,["children","onSubmit","value"]);return u.createElement(H,{value:o},u.createElement("form",p({onSubmit:s=>{s.preventDefault(),e&&e(s)}},n),r))}import{useContext as D}from"react";import{useObserver as N}from"react-ob";var _={names:[],values:{},errors:{},onChange:(r,e)=>{},keepValues:r=>{}};function q(r,e,o){if(!r)return _;N(r,t=>{let s=[];return o?o=="error"?(e.forEach(f=>{s.push(r.errors[f])}),s):(e.forEach(f=>{s.push(t[f])}),s):(e.forEach(f=>{s.push(t[f]),s.push(r.errors[f])}),s)});let n={},i={};return e.forEach(t=>{n[t]=r.val[t],i[t]=r.errors[t]||""}),{names:e,values:n,errors:i,onChange:(t,s)=>{r.val[t]=s,r.next()},keepValues:r.keepValues}}function kr(r,e){let o=D(m);return q(o,r,e)}import{useMemo as z,useRef as G}from"react";import{CreateObserver as I}from"react-ob";function Lr({initialValues:r,initErrors:e,validate:o,validateSchema:n,handleChange:i}){let t=G(I(r));return z(()=>{let s=Object.keys(r),f={};return s.forEach(a=>{f[a]=!1}),t.current=b(p({},t.current),{validate:o,errors:e||{},fields:s,touched:f,validateSchema:n,findFirstError:()=>{let a=t.current.validateSchema;if(a.isSoke)return a.firstError(t.current.errors);let d=t.current.fields,l="";return d.forEach(c=>{!l&&t.current.errors[c]&&(l=t.current.errors[c])}),l},validateAll:()=>y(this,null,function*(){let a=t.current.validateSchema;return a.isSoke?a.schemaKeys.forEach(d=>{t.current.touched[d]=!0}):t.current.fields.forEach(l=>{t.current.touched[l]=!0}),yield T(t.current),t.current.findFirstError()}),validateKey:a=>y(this,null,function*(){return t.current.touched[a]=!0,yield T(t.current,a),t.current.errors[a]}),keepValues:a=>{let d=a||t.current.fields,l={};return d.forEach(c=>{l[c]=t.current.val[c]}),l},handleChange:i}),t.current},[])}export{ar as ErrorMessage,dr as Field,mr as FieldHOC,hr as LessForm,g as useField,M as useFieldByContext,kr as useFields,q as useFieldsByContext,Lr as useForm};
