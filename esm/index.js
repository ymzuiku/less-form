var R=Object.defineProperty,j=Object.defineProperties;var w=Object.getOwnPropertyDescriptors;var T=Object.getOwnPropertySymbols;var S=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable;var P=(r,e,t)=>e in r?R(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,d=(r,e)=>{for(var t in e||(e={}))S.call(e,t)&&P(r,t,e[t]);if(T)for(var t of T(e))k.call(e,t)&&P(r,t,e[t]);return r},E=(r,e)=>j(r,w(e));var m=(r,e)=>{var t={};for(var n in r)S.call(r,n)&&e.indexOf(n)<0&&(t[n]=r[n]);if(r!=null&&T)for(var n of T(r))e.indexOf(n)<0&&k.call(r,n)&&(t[n]=r[n]);return t};var y=(r,e,t)=>new Promise((n,s)=>{var o=i=>{try{u(t.next(i))}catch(c){s(c)}},a=i=>{try{u(t.throw(i))}catch(c){s(c)}},u=i=>i.done?n(i.value):Promise.resolve(i.value).then(o,a);u((t=t.apply(r,e)).next())});import*as f from"react";import{useContext as M,useEffect as A}from"react";import{useObserver as H}from"react-ob";import{createContext as B}from"react";var g=B(void 0);var b={abortEarly:!1};function L(r){return!!r._blacklist}function O(r,e,t){return y(this,null,function*(){let n={};if(t)try{yield r.validateAt(t,e,b)}catch(s){s&&s.errors&&s.errors[0]&&(n[t]=s.errors[0])}else{let s=Object.keys(e);for(let o of s)try{yield r.validateAt(o,e,b)}catch(a){a&&a.errors&&a.errors[0]&&(n[o]=a.errors[0])}}return n})}function F(r,e){let t={};return Object.keys(r.touched).forEach(n=>{if(r.touched[n]){let s=e[n];s!==void 0&&(t[n]=s)}}),t}function C(r,e){return y(this,null,function*(){if(r.validate){let t=yield Promise.resolve(r.validate(r.val,e));Object.assign(r.errors,F(r,t))}else if(r.validateSchema){if(L(r.validateSchema)){let t=yield O(r.validateSchema,r.val,e);Object.assign(r.errors,F(r,t))}else if(r.validateSchema.isSoke){let t=r.validateSchema.validate(r.val,e);Object.assign(r.errors,F(r,t))}}r.next()})}var V={name:"",value:"",error:"",onChange:r=>{},onBlur:r=>{}};function K(r,e,t){if(!r)return V;let n=H(r,o=>t?t=="error"?[r.errors[e]]:[o[e]]:[o[e],r.errors[e]]);A(()=>{r.val[e]&&s.onChange(r.val[e])},[]);let s={name:e,value:n[e]==null?"":n[e],error:typeof r.errors[e]=="undefined"?"":r.errors[e],onBlur:o=>{o.persist&&o.persist(),r.touched[e]||(r.touched[e]=!0,s.onChange(n[e]))},onChange:o=>{r.touched[e]||(r.touched[e]=!0);let a=typeof o,u;if(a==="undefined")u="";else if(a==="object"&&(o.currentTarget||o.target)){let l=o.currentTarget||o.target,p=l.type;if(p==="checkbox"||p==="radio")u=!!l.checked;else if(l.multiple){let v=l.options,x=[];for(var i=0,c=v.length;i<c;i++)v[i].selected&&x.push(v[i].value);u=x}else u=l.value}else u=o;r.val[e]=u,r.handleChange&&(r.val=r.handleChange(r.val,e)),C(r,e)}};return s}function h(r,e){let t=M(g);return K(t,r,e)}function ar({name:r}){let e=h(r,"error");return f.createElement(f.Fragment,null,e.error)}function fr(n){var s=n,{name:r,children:e}=s,t=m(s,["name","children"]);let o=h(r);return f.createElement("input",d({name:r,value:o.value,onChange:o.onChange,onBlur:o.onBlur},t))}function pr(r,e){return function(o){var a=o,{name:n}=a,s=m(a,["name"]);if(n){let u=h(n,e);return f.createElement(r,d(d({},u),s))}return f.createElement(r,d({},s))}}var Y=g.Provider;function gr(s){var o=s,{children:r,onSubmit:e,value:t}=o,n=m(o,["children","onSubmit","value"]);return f.createElement(Y,{value:t},f.createElement("form",d({onSubmit:a=>{a.preventDefault(),e&&e(a)}},n),r))}import{useContext as I}from"react";import{useObserver as D}from"react-ob";var N={names:[],values:{},errors:{},onChange:(r,e)=>{},keepValues:r=>{}};function _(r,e,t){if(!r)return N;D(r,o=>{let a=[];return t?t=="error"?(e.forEach(u=>{a.push(r.errors[u])}),a):(e.forEach(u=>{a.push(o[u])}),a):(e.forEach(u=>{a.push(o[u]),a.push(r.errors[u])}),a)});let n={},s={};return e.forEach(o=>{n[o]=r.val[o],s[o]=r.errors[o]||""}),{names:e,values:n,errors:s,onChange:(o,a)=>{r.val[o]=a,r.next()},keepValues:r.keepValues}}function Fr(r,e){let t=I(g);return _(t,r,e)}import{useMemo as q,useRef as z}from"react";import{CreateObserver as G}from"react-ob";function br({initialValues:r,initErrors:e,validate:t,validateSchema:n,handleChange:s}){let o=z(G(r));return q(()=>{let a=Object.keys(r),u={};return a.forEach(i=>{u[i]=!1}),o.current=E(d({},o.current),{validate:t,errors:e||{},fields:a,touched:u,validateSchema:n,findFirstError:()=>{let i=o.current.validateSchema;if(i.isSoke)return i.firstError(o.current.errors);let c=o.current.fields,l="";return c.forEach(p=>{!l&&o.current.errors[p]&&(l=o.current.errors[p])}),l},validateAll:()=>y(this,null,function*(){let i=o.current.validateSchema;return i.isSoke?i.schemaKeys.forEach(c=>{o.current.touched[c]=!0}):o.current.fields.forEach(l=>{o.current.touched[l]=!0}),yield C(o.current),o.current.findFirstError()}),validateKey:i=>y(this,null,function*(){return o.current.touched[i]=!0,yield C(o.current,i),o.current.errors[i]}),keepValues:i=>{let c=i||o.current.fields,l={};return c.forEach(p=>{l[p]=o.current.val[p]}),l},handleChange:s}),o.current},[])}export{ar as ErrorMessage,fr as Field,pr as FieldHOC,gr as LessForm,h as useField,K as useFieldByContext,Fr as useFields,_ as useFieldsByContext,br as useForm};
